package io.github.maxar.MGPSDK;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import java.io.IOException;
import java.util.HashMap;
import okhttp3.Response;
import org.locationtech.jts.geom.Geometry;

/**
 *  Object generated by {@link Analytics.Builder} that allows the user to make OGC compliant calls
 *  from the Maxar Streaming APIs
 */
public class Analytics extends Ogc {

    Analytics(Builder builder) {
        super(builder);
        this.setEndpoint("analytics");
    }

    /**
     * Wrapper method that returns a new instance of the Builder object
     *
     * @return {@link Analytics.Builder}
     */
    public static Analytics.Builder builder() {
        return new Analytics.Builder();
    }

    /**
     * <p>Builder for new instances of {@link Analytics}</p>
     * <p>No fields are mandatory when {@link #build()} is called. Each <code>Analytics</code>
     * method
     * will have its own requirements that need to be set for each call. Each method will return a
     * {@link IllegalArgumentException} if required parameter are not set. Each builder method
     * returns a {@link Analytics.Builder} so that method calls can be chained until
     * {@link #build()} is finally called which will then return a completed
     * <code>Analytics</code></p>
     */
    public static class Builder extends Ogc.Builder<Analytics.Builder> {

        /**
         * Called at the end of the chained builder method. Used to return a built <code>Streaming
         * </code> object for making OGC calls
         *
         * @return <code>Analytics</code>
         * @throws IllegalArgumentException if Auth is not set properly
         */
        @Override
        public Analytics build() {
            HashMap<String, String> credentials = new HashMap<>();
            credentials.put("username", this.username);
            credentials.put("password", this.password);
            credentials.put("clientId", this.clientId);
            this.auth = new Auth(credentials);
            if (!this.filterList.isEmpty()) {
                this.rawFilter(OgcUtils.combineFilterList(this.filterList));
            }
            return new Analytics(this);
        }

        /**
         * Self method helps child classes return abstract builders
         * @return {@link Basemap.Builder}
         */
        @Override
        protected Builder self() {
            return this;
        }

    }

    /**
     * Searches using the WFS method.
     * @return FeatureCollection GeoJson result
     * @throws IllegalArgumentException if CQL filter fails check, or if builder parameters are incorrect
     */
    public AnalyticsFeatureCollection search() {

        if (this.getREQUEST_TYPE() != null) {
            throw new UnsupportedOperationException("When performing a request other than "
                + "GetFeature, searchToString() must be used");
        }
        Wfs wfs = new Wfs(this);
        if (this.getFilter() != null) {
            OgcUtils.cqlChecker(this.getFilter());
        }
        Response wfsResults = wfs.search();
        String stringWfsResults = null;
        try {
            assert wfsResults.body() != null;
            stringWfsResults = wfsResults.body().string();
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        Gson gson = new GsonBuilder()
            .registerTypeAdapter(Geometry.class, new GeometryTypeAdapter())
            .create();
        return gson.fromJson(stringWfsResults,
            AnalyticsFeatureCollection.class);

    }
}
