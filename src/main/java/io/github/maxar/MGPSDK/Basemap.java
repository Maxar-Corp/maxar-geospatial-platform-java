package io.github.maxar.MGPSDK;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import java.io.IOException;
import java.util.HashMap;
import okhttp3.Response;
import org.locationtech.jts.geom.Geometry;

/**
 *  Object generated by {@link Basemap.Builder} that allows the user to make OGC compliant calls
 *  from the Maxar Basemap APIs
 */
public class Basemap extends Ogc {

    Basemap(Builder builder) {
        super(builder);
        this.setEndpoint("basemaps");
    }

    /**
     * Wrapper method that returns a new instance of the Builder object
     * @return {@link Basemap.Builder}
     */
    public static Builder builder() {
        return  new Builder();
    }

    /**
     * <p>Builder for new instances of {@link Basemap}</p>
     * <p>No fields are mandatory when {@link #build()} is called. Each <code>Basemap</code> method
     * will have its own requirements that need to be set for each call. Each method will return a
     *  {@link IllegalArgumentException} if required parameter are not set. Each builder method
     *  returns a {@link Basemap.Builder} so that method calls can be chained until {@link #build()}
     *  is finally called which will then return a completed <code>Basemap</code></p>
     */
    public static class Builder extends Ogc.Builder<Builder> {

        /**
         * Called at the end of the chained builder method. Used to return a built <code>Streaming
         * </code> object for making OGC calls
         * @return <code>Basemap</code>
         * @throws IllegalArgumentException if Auth is not set properly
         */
        @Override
        public Basemap build() {
            HashMap<String,String> credentials = new HashMap<>();
            credentials.put("username", this.username);
            credentials.put("password", this.password);
            credentials.put("clientId", this.clientId);
            this.auth = new Auth(credentials);
            if (!this.filterList.isEmpty()) {
                this.rawFilter(OgcUtils.combineFilterList(this.filterList));
            }
            return new Basemap(this);
        }

        /**
         * Self method helps child classes return abstract builders
         * @return {@link Basemap.Builder}
         */
        @Override
        protected Builder self() {
            return this;
        }

    }

    /**
     * Searches using the WFS method.
     * @return FeatureCollection GeoJson result
     * @throws IllegalArgumentException if CQL filter fails check, or if builder parameters are incorrect
     */
    public BasemapFeatureCollection search() {

        if (this.getREQUEST_TYPE() != null) {
            throw new UnsupportedOperationException("When performing a request other than "
                + "GetFeature, searchToString() must be used");
        }
        Wfs wfs = new Wfs(this);
        if (this.getFilter() != null) {
            OgcUtils.cqlChecker(this.getFilter());
        }
        Response wfsResults = wfs.search();
        String stringWfsResults = null;
        try {
            assert wfsResults.body() != null;
            stringWfsResults = wfsResults.body().string();
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        Gson gson = new GsonBuilder()
            .registerTypeAdapter(Geometry.class, new GeometryTypeAdapter())
            .create();
        return gson.fromJson(stringWfsResults,
            BasemapFeatureCollection.class);

    }

}
