package io.github.maxar.MGPSDK;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import java.io.IOException;
import java.nio.file.InvalidPathException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import okhttp3.HttpUrl;
import okhttp3.Response;
import org.locationtech.jts.geom.Coordinate;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.GeometryFactory;
import org.locationtech.jts.geom.Polygon;

/**
 *  Object generated by {@link Streaming.Builder} that allows the user to make OGC compliant calls
 *  from the Maxar Streaming APIs
 */
public class Streaming extends Ogc {

    Streaming(Builder builder) {
        super(builder);
        this.setEndpoint("streaming");
    }

    /**
     * Wrapper method that returns a new instance of the Builder object
     * @return {@link Builder}
     */
    public static Builder builder() {
        return new Builder();
    }

    /**
     * <p>Builder for new instances of {@link Streaming}</p>
     * <p>No fields are mandatory when {@link #build()} is called. Each <code>Streaming</code> method will
     *  have its own requirements that need to be set for each call. Each method will return a
     *  {@link IllegalArgumentException} if required parameter are not set. Each builder method
     *  returns a {@link Streaming.Builder} so that method calls can be chained until {@link #build()}
     *  is finally called which will then return a completed <code>Streaming</code></p>
     *  <p>Some attributes will be used more often than others. For example:</p>
     *  <ul>
     *      <li>{@link #bbox(String)}</li>
     *      <li>{@link #filter(String)}</li>
     *  </ul>
     */
    public static class Builder extends Ogc.Builder<Builder> {

        /**
         * Called at the end of the chained builder method. Used to return a built <code>Streaming
         * </code> object for making OGC calls
         * @return <code>Streaming</code>
         * @throws IllegalArgumentException if Auth is not set properly
         */
        @Override
        public Streaming build() {
            HashMap<String,String> credentials = new HashMap<>();
            credentials.put("username", this.username);
            credentials.put("password", this.password);
            credentials.put("clientId", this.clientId);
            this.auth = new Auth(credentials);
            if (!this.filterList.isEmpty()) {
                this.rawFilter(OgcUtils.combineFilterList(this.filterList));
            }
            return new Streaming(this);
        }

        /**
         * Self method helps child classes return abstract builders
         * @return {@link Streaming.Builder}
         */
        @Override
        protected Builder self() {
            return this;
        }


    }

    /**
     * Searches using the WFS method.
     * @return FeatureCollection GeoJson result
     * @throws IllegalArgumentException if CQL filter fails check, or if builder parameters are incorrect
     */
    public StreamingFeatureCollection search() {

        if (this.getREQUEST_TYPE() != null) {
            throw new UnsupportedOperationException("When performing a request other than "
                + "GetFeature, searchToString() must be used");
        }
        Wfs wfs = new Wfs(this);
        if (this.getFilter() != null) {
            OgcUtils.cqlChecker(this.getFilter());
        }
        Response wfsResults = wfs.search();
        String stringWfsResults = null;
        try {
            assert wfsResults.body() != null;
            stringWfsResults = wfsResults.body().string();
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        Gson gson = new GsonBuilder()
            .registerTypeAdapter(Geometry.class, new GeometryTypeAdapter())
            .create();

        return gson.fromJson(stringWfsResults, StreamingFeatureCollection.class);
    }

    /**
     * Accepts a feature id and breaks the image up into 1024x1024 tiles, then places
     * a number of multithreaded calls to return a full image strip in multiple tiles. FeatureId
     * is required. A bbox can be provided if the entire feature is not needed
     * @throws IllegalArgumentException if builder parameters are not set correctly
     *
     */
    public void getFullResImage() throws IllegalArgumentException {

        if (!(((Number) this.getTHREAD_NUMBER()).doubleValue() != 0)) {
            throw new IllegalArgumentException("Must provide number of threads to use");
        }
        if (this.getFEATURE_ID() == null) {
            throw new IllegalArgumentException("GetFullResImage requires a feature ID");
        }

        StreamingFeatureCollection wfsRequest = this.search();
        Coordinate[] imageBbox = wfsRequest.features()[0].geometry().getCoordinates();
        double[] xCoords = new double[imageBbox.length];
        double[] yCoords = new double[imageBbox.length];
        for (int i = 0; i < imageBbox.length; i++) {
            xCoords[i] = imageBbox[i].x;
            yCoords[i] = imageBbox[i].y;
        }
        Arrays.sort(xCoords);
        Arrays.sort(yCoords);

        String srsname = this.getSrsname() != null ? this.getSrsname() : "EPSG:4326";
        double yValue = srsname.equals("EPSG:4326") ? 0.0042176 : 468.1536;
        double xValue = srsname.equals("EPSG:4326") ? 0.0054932 : 468.1536;
        double minY = yCoords[0];
        double minX = xCoords[0];
        double maxY = yCoords[yCoords.length - 1] + yValue;
        double maxX = xCoords[xCoords.length - 1] + xValue;
        if (this.getBbox() != null) {
            OgcUtils.validateBbox(this);
            String[] bboxList = this.getBbox().split(",");
            minY = Math.max(minY, Double.parseDouble(bboxList[0]));
            maxY = Math.min(maxY, Double.parseDouble(bboxList[2])) + yValue;
            minX = Math.max(minX, Double.parseDouble(bboxList[1]));
            maxX = Math.min(maxX, Double.parseDouble(bboxList[3])) + xValue;
        }
        // Generate a Hashmap that splits the bbox into col row tiles
        ArrayList<Double> yList = new ArrayList<>();
        ArrayList<Double> xList = new ArrayList<>();
        while (minY < maxY) {
            yList.add(minY);
            minY += yValue;
        }
        Double[] yListArr = new Double[yList.size()];
        yListArr = yList.toArray(yListArr);
        while (minX < maxX) {
            xList.add(minX);
            minX += xValue;
        }
        Double[] xListArr = new Double[xList.size()];
        xListArr = xList.toArray(xListArr);
        HashMap<String, String> tiles = new HashMap<>();

        if (srsname.equals("EPSG:4326")) {
            if (yListArr.length == 1) {
                if (xList.size() == 1) {
                    tiles.put("c0_r0", String.format("%s, %s, %s, %s", yListArr[0], xListArr[0],
                        yListArr[0] + yValue, xListArr[0] + xValue));
                } else {
                    for (int i = 0; i < xListArr.length - 1; i++) {
                        tiles.put(String.format("c%s_r%s", xListArr[i], 0), String.format("%s, %s, %s, %s",
                            yListArr[0], xListArr[i], yListArr[0] + yValue, xListArr[i + 1]));
                    }
                }
            } else if (xListArr.length == 1) {
                for (int i = yListArr.length - 1; i >= 0; i--) {
                    tiles.put(String.format("c%s_r%s", 0, yListArr.length - 2), String.format("%s, %s, %s, %s",
                        yListArr[i], xListArr[0], yListArr[i + 1], xListArr[0] + xValue));
                }
            } else {
                for (int i = yListArr.length - 2; i >= 0; i--) {
                    for (int j = 0; j < xListArr.length - 1; j++) {
                        tiles.put(String.format("c%s_r%s", j, yListArr.length - i - 2),
                            String.format("%s, %s, %s, %s", yListArr[i], xListArr[j], yListArr[i + 1], xListArr[j + 1]));
                    }
                }
            }
        } else {
            if (yListArr.length == 1) {
                if (xList.size() == 1) {
                    tiles.put("c0_r0", String.format("%s, %s, %s, %s", xListArr[0], yListArr[0],
                        xListArr[0] + xValue, yListArr[0] + yValue));
                } else {
                    for (int i = 0; i < xListArr.length - 1; i++) {
                        tiles.put(String.format("c%s_r%s", xListArr[i], 0), String.format("%s, %s, %s, %s",
                            xListArr[i], yListArr[0], xListArr[i + 1], yListArr[0] + yValue));
                    }
                }
            } else if (xListArr.length == 1) {
                for (int i = yListArr.length - 1; i >= 0; i--) {
                    tiles.put(String.format("c%s_r%s", 0, yListArr.length - 2), String.format("%s, %s, %s, %s",
                        xListArr[0], yListArr[i], xListArr[0] + xValue, yListArr[i]));
                }
            } else {
                for (int i = yListArr.length - 2; i >= 0; i--) {
                    for (int j = 0; j < xListArr.length - 1; j++) {
                        tiles.put(String.format("c%s_r%s", j, yListArr.length - i - 2),
                            String.format("%s, %s, %s, %s", yListArr[i], xListArr[j], yListArr[i + 1], xListArr[j + 1]));
                    }
                }
            }
        }

        //This section deletes bboxes that don't cover the image from Tiles
        StreamingFeatureCollection wfsResponse = this.search();
        this.setSrsname(srsname);
        GeometryFactory geometryFactory = new GeometryFactory();

        Iterator<Entry<String, String>> it = tiles.entrySet().iterator();
        while (it.hasNext()) {
            HashMap.Entry<String, String> entry = it.next();
            Geometry featureArea = wfsResponse.features()[0].geometry().getEnvelope();
            String[] bboxList = entry.getValue().split(",");
            // Create a polygon from the bbox
            double bboxMinX = Double.parseDouble(bboxList[1]);
            double bboxMinY = Double.parseDouble(bboxList[0]);
            double bboxMaxX = Double.parseDouble(bboxList[3]);
            double bboxMaxY = Double.parseDouble(bboxList[2]);
            Coordinate[] bboxCoordinates = new Coordinate[] {
                new Coordinate(bboxMinX, bboxMinY),
                new Coordinate(bboxMinX, bboxMaxY),
                new Coordinate(bboxMaxX, bboxMaxY),
                new Coordinate(bboxMaxX, bboxMinY),
                new Coordinate(bboxMinX, bboxMinY),
            };
            Polygon bboxPolygon = geometryFactory.createPolygon(bboxCoordinates);
            Geometry overlap = bboxPolygon.intersection(featureArea);

            if (overlap.getArea() == 0.0) {
                it.remove();
            }
        }

        //Initiate a custom querystring
        Wms fullResWms = new Wms(this);
        HashMap<String, String> querystring = fullResWms.initQueryString();
        querystring.put("crs", srsname);
        querystring.put("width", "1024");
        querystring.put("height", "1024");
        querystring.put("cql_filter", String.format("featureId='%s'", this.getFEATURE_ID()));
        if (this.getIMAGE_FORMAT() != null) {
            OgcUtils.validateImageFormat(this);
            querystring.put("format", this.getParamsImageFormat());
        } else {
            throw new IllegalArgumentException("Must provide an image format");
        }

        //Build list of API urls from bbox list
        HashMap<String, String> multiThreadingMap = new HashMap<>();
        it = tiles.entrySet().iterator();
        while (it.hasNext()) {
            HashMap.Entry<String, String> entry = it.next();
            querystring.put("bbox", entry.getValue());
            String url = String.format("%s/%s/%s/ogc/wms", this.getAUTH().getAPI_BASE_URL(),
                this.getENDPOINT(), this.getAUTH().getAPI_VERSION());
            HttpUrl.Builder urlBuilder = Objects.requireNonNull(HttpUrl.parse(url)).newBuilder();

            //Build params from querystring
            for (Map.Entry<String, String> set : querystring.entrySet()) {
                urlBuilder.addQueryParameter(set.getKey(), set.getValue());
            }
            multiThreadingMap.put(entry.getKey(), urlBuilder.build().toString());
        }
        System.out.println("Number of tiles: " + multiThreadingMap.size());

        if (this.getDownloadPath() != null) {
            try {
                Paths.get(this.getDownloadPath());
            } catch (InvalidPathException ipe) {
                throw new IllegalArgumentException("Path " + this.getDownloadPath() + " not a valid path");
            }
        } else {
            this.setDownloadPath(String.format("%s/Downloads/%s", System.getProperty("user.home"), "Tiles"));
        }

        System.out.println("Starting full image download process...");
        //call util function to handle full download
        int failedDownloads = OgcUtils.handleMultithreadDownload(multiThreadingMap, this);

        System.out.println("Download complete!");
        System.out.println("Number of failed requests: " + failedDownloads);
        System.out.println("Tiles downloaded to " + this.getDownloadPath());


    }

}